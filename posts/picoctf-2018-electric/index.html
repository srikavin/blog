<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="picoCTF 2018 - eleCTRic" property="og:title"><meta content="article" property="og:type"><meta content="2018-10-13T02:36:19.176Z" property="og:published_time"><meta content="2018-12-28T23:10:12.884Z" property="og:modified_time"><meta content="Srikavin Ramkumar" property="og:author"><meta content="ctf-writeups" property="og:section"><meta content="picoctf18" property="og:tag"><meta content="cryptography" property="og:tag"><meta content="aes-ctr" property="og:tag"><meta content="aes" property="og:tag"><meta content="https://blog.srikavin.me/posts/picoctf-2018-electric/" property="og:url"><title>picoCTF 2018 - eleCTRic - srikavin.me</title><link href="/favicon.png" rel="icon"><link href="/bundle.css" rel="stylesheet"><script src="https://www.googletagmanager.com/gtag/js?id=G-X8ZVFPQ0CK" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-X8ZVFPQ0CK');</script></head><body><nav><div class="nav-left"><span><a href="https://srikavin.me" class="name">Srikavin Ramkumar</a> </span><span><a href="/posts" class="nav-link">Posts</a> </span><span><a href="/tags" class="nav-link">Tags</a></span></div><div class="nav-right"><a href="https://github.com/srikavin"><img alt="Github" src="/gh-logo.png" height="24px" width="24px"></a></div></nav><section class="section"><div class="container"><div class="page-container"><div class="blog-header"><h1 class="title">picoCTF 2018 - eleCTRic</h1><div class="subtitle"><span>Posted on <span class="date" title="Created: 2018-10-13T02:36:19.176Z&#10;Updated: 2018-12-28T23:10:12.884Z">October 13, 2018* </span>in ctf-writeups</span></div><div class="tags"><a href="https:&#x2F;&#x2F;blog.srikavin.me&#x2F;tags&#x2F;picoctf18&#x2F;"><span class="interactive minimal tag">picoctf18</span></a> <a href="https:&#x2F;&#x2F;blog.srikavin.me&#x2F;tags&#x2F;cryptography&#x2F;"><span class="interactive minimal tag">cryptography</span></a> <a href="https:&#x2F;&#x2F;blog.srikavin.me&#x2F;tags&#x2F;aes-ctr&#x2F;"><span class="interactive minimal tag">aes-ctr</span></a> <a href="https:&#x2F;&#x2F;blog.srikavin.me&#x2F;tags&#x2F;aes&#x2F;"><span class="interactive minimal tag">aes</span></a></div></div><div class="blog-content light"><div class="blog-scrollspy"><h1 class="scrollspy-label">Table of Contents</h1><ul><li><a href="#problem" data-target="problem">Problem</a></li><li><a href="#solution" data-target="solution">Solution</a><ul><li><a href="#solve-script" data-target="solve-script">Solve Script</a></li></ul></li></ul></div><h1 id="problem">Problem</h1><blockquote><p>&quot;You came across a custom server that Dr Xernon's company eleCTRic Ltd uses. It seems to be storing some encrypted files. Connect with <code>nc 2018shell2.picoctf.com 15037</code>. Can you get us the flag?&quot; <a href="https://2018shell2.picoctf.com/static/61d78e61c2bd099775499bba7edc1d62/eleCTRic.py">Source</a></p></blockquote><h1 id="solution">Solution</h1><p>The title makes a clear reference to <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)">AES-CTR</a>. We can see that this mode of AES requires a unique nonce for each encrypted value to remain cryptographically secure. If we look at the problem's source code, we can see that the counter remains constant for all values. This breaks the encryption used and we are able to reveal the keystream and encrypt arbritary data.</p><pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">class </span><span style="color:#0086b3;">AESCipher</span><span style="color:#323232;">(</span><span style="color:#0086b3;">object</span><span style="color:#323232;">):
    </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#62a35c;">__init__</span><span style="color:#323232;">(self):
        self.bs </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">32
        </span><span style="color:#323232;">random </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Random.new()
        self.key </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">random.read(</span><span style="color:#0086b3;">AES</span><span style="color:#323232;">.block_size)
        self.ctr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">random.read(</span><span style="color:#0086b3;">AES</span><span style="color:#323232;">.block_size)

    </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">encrypt</span><span style="color:#323232;">(self, raw):
        cipher </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">AES.new(self.key, </span><span style="color:#0086b3;">AES</span><span style="color:#323232;">.</span><span style="color:#0086b3;">MODE_CTR</span><span style="color:#323232;">, counter</span><span style="font-weight:bold;color:#a71d5d;">=lambda</span><span style="color:#323232;">: self.ctr)
        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">cipher.encrypt(raw).encode(</span><span style="color:#183691;">&#39;base64&#39;</span><span style="color:#323232;">).replace(</span><span style="color:#183691;">&#39;</span><span style="color:#0086b3;">\n</span><span style="color:#183691;">&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;&#39;</span><span style="color:#323232;">)
</span></code></pre><span id="continue-reading"></span><p><img alt="" src="https://blog.srikavin.me/posts/picoctf-2018-electric/5bc12eb5b7c5001b74f57e49.png"></p><p>AES-CTR simply XORS the plaintext with the keystream (a value derived from the key and the counter).</p><p>To understand the exploit, it is important to know the following XOR rules (where âŠ• indicates XOR): $$ a \oplus a = 0 \ a \oplus b = b \oplus a \ (a \oplus b) \oplus c = (c \oplus b) \oplus a $$</p><p>AES-CTR can be understood as the following, where F is some deterministic function:</p><p>$$ C = P \oplus F(key, nonce) $$</p><p>Given the following: $$ P_1 = \text{plaintext 1} \ C_1 = \text{ciphertext 1} \ P_2 = \text{ciphertext 2} $$ It is possible to find $C_2$.</p><p>$$ C_1=P_1 \oplus F(key, nonce)\ $$ We can rearrange the equation to the following: $$ C_1 \oplus P_1 = F(key, nonce) $$ Then we can subsitute $C_1 \oplus P_1$ for $F(key, nonce)$ $$ C_2 = P_2 \oplus F(key,nonce)\ C_2 = P_2 \oplus C_1 \oplus P_1 $$</p><p>We are able to arbitrarily encrypt any data we want if we have two cipher texts with the same nonce.</p><h2 id="solve-script">Solve Script</h2><pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">from </span><span style="color:#323232;">base64 </span><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#323232;">b64decode, b64encode

flag_file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;&quot; </span><span style="font-style:italic;color:#969896;"># The value to encrypt
</span><span style="color:#323232;">known_plaintext </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;ABCDEFGHABCDEFGHABCDEFGHABCD&quot; </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#183691;">&quot;.txt&quot;
</span><span style="color:#323232;">known_cipher_b64 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;d8bImO+u0C2MOOfGkfdOoHfGyJjvrtAtjDjnxvrFcZw=&quot; </span><span style="font-style:italic;color:#969896;"># The encrypted version of known_plaintext
</span><span style="color:#323232;">known_cipher </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">b64decode(known_cipher_b64)

</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;known_cipher length </span><span style="color:#0086b3;">%d</span><span style="color:#183691;">&quot; </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#62a35c;">len</span><span style="color:#323232;">(known_cipher))

</span><span style="font-style:italic;color:#969896;">#Encryption and decryption are symmetric operations; encrypting a ciphertext will reveal its value
</span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#323232;">encrypt</span><span style="color:#323232;">(key, plaintext):
    ret </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">bytearray</span><span style="color:#323232;">()
    </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#62a35c;">range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#62a35c;">len</span><span style="color:#323232;">(plaintext)):
        ret.append(key[i</span><span style="font-weight:bold;color:#a71d5d;">%</span><span style="color:#62a35c;">len</span><span style="color:#323232;">(key)] </span><span style="font-weight:bold;color:#a71d5d;">^ </span><span style="color:#62a35c;">ord</span><span style="color:#323232;">(plaintext[i]))
    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">ret

</span><span style="font-style:italic;color:#969896;">#Calculate the key-stream from the known cipher and the known plaintext
</span><span style="color:#323232;">key </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">bytearray</span><span style="color:#323232;">()
</span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#62a35c;">range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">32</span><span style="color:#323232;">):
    key.append(known_cipher[i] </span><span style="font-weight:bold;color:#a71d5d;">^ </span><span style="color:#62a35c;">ord</span><span style="color:#323232;">(known_plaintext[i]))


</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;key </span><span style="color:#0086b3;">%s</span><span style="color:#183691;">&quot; </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#323232;">key)
</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;key length </span><span style="color:#0086b3;">%d</span><span style="color:#183691;">&quot; </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#62a35c;">len</span><span style="color:#323232;">(key))

</span><span style="font-style:italic;color:#969896;">#Verify the encryption remains the same for the known_plaintext
</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(b64encode(encrypt(key, known_plaintext)))
</span><span style="font-style:italic;color:#969896;">#Print actual encrypted text
</span><span style="color:#62a35c;">print</span><span style="color:#323232;">(b64encode(encrypt(key, flag_file)))
</span></code></pre></div></div><script src="https://utteranc.es/client.js" async crossorigin="anonymous" issue-term="url" label="ðŸ’¬comments" repo="srikavin/blog" theme="github-light"></script></div></section><script src="/bundle.js"></script></body></html>